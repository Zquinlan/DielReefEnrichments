nest()%>%
mutate(data = map(data, ~aov(log_value ~ Organism, .x)%>%
TukeyHSD(p.adjust.methods = "BH")%>%
tidy()))%>%
unnest(data)%>%
filter(adj.p.value < 0.05)
source("~/Documents/R_scripts/pipelines/DOM_feature_remover.R")
## Script Written by Zach Quinlan 06/19/19
# Re-organization of DORCIERR_FCM_fDOM.R because it needs to be cleaner 07/15/2019
# Only working on daytime exudation and remineralization
# Rewritten with changes to RR3 starting pipeline 10/11/2019
# 16s rRNA amplicon seque3nce data added in a upaded 10/18/2019
# Added in ClassyFire annotations from Inchi_keys 10/07/2019
# This has been rewritten for the new pipeline 12/18/2019
# LOADING -- packages -------------------------------------------------------
#Data mungering
library(tidyverse)
library(data.table)
library(DescTools)
library(broom)
library(readxl)
library(multcomp)
library(CHNOSZ)
library(furrr)
library(future)
library(biclustermd)
library(webchem)
library(classyfireR)
library(randomForest)
library(ggpubr)
#PCoA, PERMANOVA
library(vegan)
library(ape)
#Visualizations
library(wesanderson)
library(RColorBrewer)
library(gplots)
library(gtable)
#Defining functions and removing issues with overlapping function calls
map <- purrr::map
select <- dplyr::select
tidy <- broom::tidy
rename <- dplyr::rename
zscore <- function(x) {
(x-mean(x, na.rm = TRUE))/sd(x, na.rm = TRUE)
}
# CORES -- setting processors available -----------------------------------
##Only used if future_mapping
# num_cores <- availableCores() -1
# don't murder your compututer and save your self a core
# this is the parellel planning step (changes global env so this is plan for all parellel
# work unless specificed otherwise)
# plan(multiprocess, workers = num_cores) #defaults to sequential process, multiprocess is one option for parellel
# LOADING -- dataframes  ------------------------------------------------------
## FCM and fDOM data
dorc_fcm_fdom <- read_xlsx("~/Documents/GitHub/DORCIERR/data/raw/DOC_fDOM_FCM/DORCIERR_fDOM_FCM.xlsx")%>%
rename(sample_name =`Sample Name of DORCIERR_FCM_Final`)%>%
rename('DayNight' = 'Experiment')%>%
rename(Organism = 'Organsim')%>%
mutate(Organism = case_when(Organism == "Water" ~ "Water control",
TRUE ~ as.character(Organism)))
#DOC data
moorea_doc <- read_xlsx("~/Documents/GitHub/DORCIERR/data/raw/DOC_fDOM_FCM/MO17_ExpSummary_DOC.2018.04.04.xlsx")%>%
dplyr::select(1:2)%>%
rename(sample_name = 1)%>%
rename(DOC = 2)
# True hits and analog hits are exported CSVs from GNPS
# True hits are more strictly matched to the library
true_hits <- read_tsv("~/Documents/GitHub/DORCIERR/data/raw/metabolomics/Library-hits.tsv")%>%
rename("feature_number" = '#Scan#')
analog_hits <- read_tsv("~/Documents/GitHub/DORCIERR/data/raw/metabolomics/Analog-hits.tsv")%>%
rename("feature_number" = '#Scan#')
# Node info includes networking information about each feature
node_info <- read_tsv("~/Documents/GitHub/DORCIERR/data/raw/metabolomics/Node_info.tsv")%>%
rename('feature_number' = 'cluster index',
'network' = 'componentindex')
csi_finger_id <- read_tsv("~/Documents/GitHub/DORCIERR/data/raw/metabolomics/summary_csi_fingerid.tsv")%>%
rename(feature_number = experimentName)
# Canopus tries to classify each feature
canopus_anotations <- read_csv("~/Documents/GitHub/DORCIERR/data/raw/metabolomics/Canopus_classes.csv")
chemont_anotations <- read_csv("~/Documents/GitHub/DORCIERR/data/raw/metabolomics/categories.canopus.strings.nelsonMarch2019.CSV")%>%
rename('canopus_annotation' = 'name')
# Sirius and Zodiac both try to assign molecular formulas to all the features
sirius_zodiac_anotations <- read_csv("~/Documents/GitHub/DORCIERR/data/raw/metabolomics/SIRIUS_Zodiac_converted.csv")%>%
rename(feature_number = 1)%>%
dplyr::select(-c(14:ncol(.)))
# Feature table has all features found within the experiments and blanks
# The columns need to be changed to the actual experiment sample codes
# Feature_table_raw is the raw export from MZMine
feature_table_raw <- read_csv("~/Documents/GitHub/DORCIERR/data/raw/metabolomics/Morrea_Feayures-Table_all_Gap-Filled5.csv")%>%
rename('feature_number' = 'row ID')
ms_sample_codes <- read_csv("~/Documents/GitHub/DORCIERR/data/raw/metabolomics/Mo'orea 2017 Mass spec sample codes - Sheet1.csv")%>%
rename('run_code' = 'Sample ID',
'sample_code' = 'Sample Name')
# 16s rRNA sequences
microbe_abundance_raw <- read_tsv("~/Documents/GitHub/DORCIERR/data/raw/microbes/MCR2017.16S.Nelson.Pipeline.October2019/abundance_table_100.shared.tsv")
microbe_taxonomy <- read_tsv("~/Documents/GitHub/DORCIERR/data/raw/microbes/MCR2017.16S.Nelson.Pipeline.October2019/annotations_100.taxonomy.tsv")
# NAP
nap_df <- read_tsv("~/Documents/GitHub/DORCIERR/data/raw/metabolomics/moorea2017_NAP.tsv")%>%
rename("feature_number" = "cluster.index")
inchikey_df <- read_csv("~/Documents/SDSU/Moorea_2017/csi_inchikey.csv")%>%
mutate(feature_number = as.character(feature_number))
# CLEANING -- SIRIUS_Zodiac elemental composition of molecular formulas -------------------------------------------
networking_elements <- sirius_zodiac_anotations%>%
filter(!ZodiacMF == "not_explainable")%>%
group_by(feature_number)%>%
do(., rownames_to_column(as.data.frame(makeup(.$ZodiacMF, multiplier = 1), var = "element")))%>%
spread(rowname, 3)
networking_elements[is.na(networking_elements)] <- 0
#Filter NOSC and Zodiac
networking_energy <- networking_elements%>%
dplyr::select(c(1, 'C', 'H', 'N', 'O', 'P', 'S'))%>%
add_column(NOSC = (-((4*.$C + .$H - 3*.$N - 2*.$O + 5*.$P - 2*.$S)/.$C)+4))%>%
add_column(dG = 60.3-28.5*.$NOSC)%>%
filter(NOSC < 4 & NOSC > -4)%>%
filter(P <= 2)
# CLEANING -- Canopus---------------------------
canopus_annotation_names <- canopus_anotations%>%
gather(canopus_annotation, canopus_probability, 2:ncol(.))
canopus_chemonnt_tidy <- left_join(canopus_annotation_names, chemont_anotations, by = "canopus_annotation")
# SET -- CANOPUS filters --------------------------------------------------
# Canopus annotations which are above level 3 AND 80% probability
canopus_filtered_tidy <- canopus_chemonnt_tidy%>%
rename('feature_number' = 'name')%>%
group_by(feature_number)%>%
nest()%>%
mutate(data = map(data, ~filter(.x, canopus_probability >= 0.80)%>%
filter(level > 3)%>%
# filter(., level == max(level))%>%
filter(canopus_probability == max(canopus_probability))%>%
filter(level == max(level))%>%
filter(nchar(CLASS_STRING) == max(nchar(CLASS_STRING)))%>%
filter(nchar(canopus_annotation) == max(nchar(canopus_annotation)))))%>%
unnest(data)
write_csv(canopus_filtered_tidy, "~/Documents/GitHub/DORCIERR/data/analysis/canopus_filtered_tidy.csv")
# Combines canopus, sirus, and zodiac
super_computer_annotations <- full_join(full_join(canopus_filtered_tidy,
sirius_zodiac_anotations, by = "feature_number"),
networking_energy, by = "feature_number")%>%
add_column(`characterization scores` = .$`quality`)%>%
mutate(`characterization scores` = case_when(`characterization scores` != "Good" ~ "Bad quality",
ZodiacScore < .98 ~ "Low probability",
TRUE ~ as.character(`characterization scores`)))
# CLEANING -- METADATA and filter out bad samples --------------------------
## join library hits, analog hits and super computer predictions
metadata <- full_join(node_info,
full_join(super_computer_annotations,
full_join(feature_table_raw[1:4],
full_join(true_hits, analog_hits, by = "feature_number",
suffix = c("Library_", "Analog_")),
by = "feature_number"),
by = "feature_number"),
by = "feature_number")%>%
left_join(nap_df, by = "feature_number", suffix = c("", "_nap"))%>%
left_join(csi_finger_id, by = "feature_number", suffix = c("", "_csi"))%>%
add_column(binary_ID = .$LibraryID, .before = 1)%>%
mutate(binary_ID = case_when(binary_ID != "N/A" ~ "1",
Compound_NameAnalog_ != "NA" ~ "2",
!is.na(ConsensusSC) ~ "3",
TRUE ~ as.character(binary_ID)))%>%
add_column(combined_ID = .$LibraryID, .before = 1)%>%
mutate(combined_ID = case_when(binary_ID == "1" ~ LibraryID,
binary_ID == "3" ~ ConsensusSC,
binary_ID == "2" ~ Compound_NameAnalog_,
binary_ID == "N/A" ~ canopus_annotation,
TRUE ~ as.character(binary_ID)))%>%
mutate(inchi_binary = case_when(!is.na(INCHILibrary_) ~ "1",
!is.na(INCHIAnalog_) & is.na(INCHILibrary_) |
!is.na(INCHIAnalog_) & INCHILibrary_ == "N/A" ~ "2",
TRUE ~ "3"))%>%
mutate(inchi_combined = case_when(inchi_binary == "1" ~ INCHILibrary_,
inchi_binary == "2" ~ INCHIAnalog_,
TRUE ~ "N/A"))
metadata$feature_number <- as.character(metadata$feature_number)
networking <- metadata%>%
dplyr::select(c(feature_number, network,combined_ID, binary_ID,
canopus_annotation:CLASS_STRING, ZodiacMF, `characterization scores`,
C:dG, inchi_binary, inchi_combined))%>%
separate(CLASS_STRING, c("level 1", "level 2", "level 3",
"level 4", "level 5", "level 6", "level 7", "level 8"), sep = ";")%>%
mutate(c_temp = case_when(C > 0 ~ "C",
TRUE ~ "_"),
o_temp = case_when(O > 0 ~ "O",
TRUE ~ "_"),
h_temp = case_when(H > 0 ~ "H",
TRUE~ "_"),
n_temp = case_when(N > 0 ~ "N",
TRUE ~ "_"),
p_temp = case_when(P > 0 ~ "P",
TRUE ~ "_"),
s_temp = case_when(S > 0 ~ "S",
TRUE ~ "_"))%>%
unite(simplified_makeup, c("c_temp", "h_temp", "o_temp", "n_temp", "p_temp", "s_temp"), sep = "")%>%
mutate(simplified_makeup = gsub("_","", simplified_makeup),
simplified_makeup = case_when(`characterization scores` != "Good" ~ "uncharacterized",
simplified_makeup == "" ~ "uncharacterized",
TRUE ~ as.character(simplified_makeup)))%>%
left_join(inchikey_df, by = "feature_number", suffix = c("", "_inchi"))
## making feature table so we can remove blanks
# have to change the MS codes for sample codes
# dplyr::selecting for RR3
feature_table_temp <- feature_table_raw%>%
dplyr::select(-X326)%>%
dplyr::select(-c(2:4))%>%
gather(run_code, ion_charge, 2:ncol(.))%>%
spread(feature_number, ion_charge)
feature_table_temp$run_code <- feature_table_temp$run_code%>%
gsub(".mzXML Peak area", "", .)%>%
gsub("_MSMS", "", .)
feature_table_dirty <- left_join(ms_sample_codes, feature_table_temp, by = "run_code")%>%
dplyr::select(-run_code)%>%
filter(sample_code %like any% c("%Blank%","R_%", "D_%", "M_%", "SPIFFy_%"))%>%
filter(!sample_code %like any% c("%C18%", "%XAD%"))%>%
gather(feature_number, ion_charge, 2:ncol(.))%>%
spread(sample_code, ion_charge)
# DEFINING -- Samples and blanks ------------------------------------------
## defining what columns the samples are in
ions_samples <- 10:259
## defining different blanks
ions_blanks <- c(2:8, 260)
source("~/Documents/R_scripts/pipelines/DOM_feature_remover.R")
test <- feature_table_dirty%>% flag_background()%>% flag_transient()
flag_background <- function(data, min_val = 0.5, blank_columns = contains(data, "blank", ignore.case = TRUE),
sample_columns = !contains(data, "blank", ignore.case = TRUE)) {
require("tidyverse")
data$max_blanks <- apply(data[blank_columns], 1, max)
data$mean_samples <- apply(data[sample_columns], 1, mean)
no_background <- data%>%
mutate(background_features = case_when(mean_samples*min_val > max_blanks ~ "real",
TRUE ~ "background"))%>%
dplyr::select(-c(max_blanks, mean_samples))
}
test <- feature_table_dirty%>% flag_background()%>% flag_transient()
test <- feature_table_dirty(select(contains("blank", ignore.case = TRUE)))
test <- feature_table_dirty%>% select(contains("blank", ignore.case = TRUE))
View(test)
flag_background <- function(data, min_val = 0.5, blank_columns = match(contains(data, "blank", ignore.case = TRUE),
names(data)),
sample_columns = match(!contains(data, "blank", ignore.case = TRUE),
names(data))) {
require("tidyverse")
data$max_blanks <- apply(data[blank_columns], 1, max)
data$mean_samples <- apply(data[sample_columns], 1, mean)
no_background <- data%>%
mutate(background_features = case_when(mean_samples*min_val > max_blanks ~ "real",
TRUE ~ "background"))%>%
dplyr::select(-c(max_blanks, mean_samples))
}
test <- feature_table_dirty%>% flag_background()%>% flag_transient()
blank_test <- match(contains(feature_table_dirty, "blank", ignore.case = TRUE),
names(feature_table_dirty))
?contains
flag_background <- function(data, min_val = 0.5, blank_columns = match(contains("blank", ignore.case = TRUE),
names(data)),
sample_columns = match(!contains("blank", ignore.case = TRUE),
names(data))) {
require("tidyverse")
data$max_blanks <- apply(data[blank_columns], 1, max)
data$mean_samples <- apply(data[sample_columns], 1, mean)
no_background <- data%>%
mutate(background_features = case_when(mean_samples*min_val > max_blanks ~ "real",
TRUE ~ "background"))%>%
dplyr::select(-c(max_blanks, mean_samples))
}
test <- feature_table_dirty%>% flag_background()%>% flag_transient()
blank_columns <-
select(feature_table_dirty,
contains("blank", ignore.case = TRUE))%>%
names())
blank_columns <-
+     select(feature_table_dirty,
+            contains("blank", ignore.case = TRUE))%>%
+         names()
blank_columns <-
+     names(select(feature_table_dirty,
+            contains("blank", ignore.case = TRUE)))
blank_columns <- names(select(feature_table_dirty, contains("blank", ignore.case = TRUE)))
head(blank_columns)
match(blank_columns, names(feature_table_dirty)
)
flag_background <- function(data, min_val = 0.5,
blank_columns = match(
names(
select(data,
contains("blank", ignore.case = TRUE))),
names(data)),
sample_columns = match(
names(
select(data,
!contains("blank", ignore.case = TRUE))),
names(data))) {
require("tidyverse")
data$max_blanks <- apply(data[blank_columns], 1, max)
data$mean_samples <- apply(data[sample_columns], 1, mean)
no_background <- data%>%
mutate(background_features = case_when(mean_samples*min_val > max_blanks ~ "real",
TRUE ~ "background"))%>%
dplyr::select(-c(max_blanks, mean_samples))
}
flag_transient <- function(data, sample_columns, noise_level = 2E5, replication_number = 3) {
require("tidyverse")
no_transient <- data%>%
add_column(samples_over_noise = rowSums(.[sample_columns] > noise_level), .before = 2)%>%
mutate(transient_features = case_when(samples_over_noise >= replication_number ~ "real",
TRUE ~ "transient"))%>%
dplyr::select(-samples_over_noise)
}
test <- feature_table_dirty%>% flag_background()%>% flag_transient()
flag_background <- function(data, min_val = 0.5,
blank_columns = match(
names(
select(data,
contains("blank", ignore.case = TRUE))),
names(data)),
sample_columns = match(
names(
select(data,
!contains("blank", ignore.case = TRUE))),
names(data))) {
require("tidyverse")
data$max_blanks <- apply(data[blank_columns], 1, max)
data$mean_samples <- apply(data[sample_columns], 1, mean)
no_background <- data%>%
mutate(background_features = case_when(mean_samples*min_val > max_blanks ~ "real",
TRUE ~ "background"))%>%
dplyr::select(-c(max_blanks, mean_samples))
}
test <- feature_table_dirty%>% flag_background()%>% flag_transient()
test <- feature_table_dirty%>% flag_background()
test <- feature_table_dirty%>% sample_columns = match(names(select(data, !contains("blank", ignore.case = TRUE))),
names(data)))
test <- feature_table_dirty%>% sample_columns = match(names(select(data, !contains("blank", ignore.case = TRUE))),
names(data))
test <- feature_table_dirty%>% sample_columns = match(names(select(data, contains("blank", ignore.case = TRUE))),
names(data))
blank_test <- match(contains(feature_table_dirty, "blank", ignore.case = TRUE),
)
test <- feature_table_dirty%>% select(!contains("blank", ignore.case = TRUE))
test <- feature_table_dirty%>% select(contains("blank", ignore.case = TRUE))
head(test)
test <- feature_table_dirty%>% select(!c(contains("blank", ignore.case = TRUE)))
test <- feature_table_dirty%>% select(-c(contains("blank", ignore.case = TRUE)))
test <- feature_table_dirty%>% select(-contains("blank", ignore.case = TRUE))
head(test)
flag_background <- function(data, min_val = 0.5,
blank_columns = match(
names(
select(data,
contains("blank", ignore.case = TRUE))),
names(data)),
sample_columns = match(
names(
select(data,
-contains("blank", ignore.case = TRUE))),
names(data))) {
require("tidyverse")
data$max_blanks <- apply(data[blank_columns], 1, max)
data$mean_samples <- apply(data[sample_columns], 1, mean)
no_background <- data%>%
mutate(background_features = case_when(mean_samples*min_val > max_blanks ~ "real",
TRUE ~ "background"))%>%
dplyr::select(-c(max_blanks, mean_samples))
}
test <- feature_table_dirty%>% flag_background()
warnings()
data$max_blanks <- apply(data[blank_columns], 1, max)
data$mean_samples <- apply(data[sample_columns], 1, mean, na.rm = TRUE)
flag_background <- function(data, min_val = 0.5,
blank_columns = match(
names(
select(data,
contains("blank", ignore.case = TRUE))),
names(data)),
sample_columns = match(
names(
select(data,
-contains("blank", ignore.case = TRUE))),
names(data))) {
require("tidyverse")
data$max_blanks <- apply(data[blank_columns], 1, max)
data$mean_samples <- apply(data[sample_columns], 1, mean, na.rm = TRUE)
no_background <- data%>%
mutate(background_features = case_when(mean_samples*min_val > max_blanks ~ "real",
TRUE ~ "background"))%>%
dplyr::select(-c(max_blanks, mean_samples))
}
test <- feature_table_dirty%>% flag_background()
data$mean_samples <- apply(data[sample_columns], 1, mean(na.rm = TRUE),)
flag_background <- function(data, min_val = 0.5,
blank_columns = match(
names(
select(data,
contains("blank", ignore.case = TRUE))),
names(data)),
sample_columns = match(
names(
select(data,
-contains("blank", ignore.case = TRUE))),
names(data))) {
require("tidyverse")
data$max_blanks <- apply(data[blank_columns], 1, max)
data$mean_samples <- apply(data[sample_columns], 1, mean(na.rm = TRUE),)
no_background <- data%>%
mutate(background_features = case_when(mean_samples*min_val > max_blanks ~ "real",
TRUE ~ "background"))%>%
dplyr::select(-c(max_blanks, mean_samples))
}
test <- feature_table_dirty%>% flag_background()
flag_background <- function(data, min_val = 0.5,
blank_columns = match(
names(
select(data,
contains("blank", ignore.case = TRUE))),
names(data)),
sample_columns = match(
names(
select(data,
-contains("blank", ignore.case = TRUE))),
names(data))) {
require("tidyverse")
data$max_blanks <- apply(data[blank_columns], 1, max)
data$mean_samples <- apply(data[sample_columns], 1, mean(na.rm = TRUE))
no_background <- data%>%
mutate(background_features = case_when(mean_samples*min_val > max_blanks ~ "real",
TRUE ~ "background"))%>%
dplyr::select(-c(max_blanks, mean_samples))
}
test <- feature_table_dirty%>% flag_background()
data$mean_samples <- apply(data[sample_columns], 1, mean, na.rm = TRUE)
flag_background <- function(data, min_val = 0.5,
blank_columns = match(
names(
select(data,
contains("blank", ignore.case = TRUE))),
names(data)),
sample_columns = match(
names(
select(data,
-contains("blank", ignore.case = TRUE))),
names(data))) {
require("tidyverse")
data$max_blanks <- apply(data[blank_columns], 1, max)
data$mean_samples <- apply(data[sample_columns], 1, mean, na.rm = TRUE)
no_background <- data%>%
mutate(background_features = case_when(mean_samples*min_val > max_blanks ~ "real",
TRUE ~ "background"))%>%
dplyr::select(-c(max_blanks, mean_samples))
}
test <- feature_table_dirty%>% flag_background()%>% flag_transient()
flag_transient <- function(data, sample_columns = match(
names(
select(data,
-contains("blank", ignore.case = TRUE))),
names(data)),
noise_level = 2E5,
replication_number = 3) {
require("tidyverse")
no_transient <- data%>%
add_column(samples_over_noise = rowSums(.[sample_columns] > noise_level), .before = 2)%>%
mutate(transient_features = case_when(samples_over_noise >= replication_number ~ "real",
TRUE ~ "transient"))%>%
dplyr::select(-samples_over_noise)
}
test <- feature_table_dirty%>% flag_background()%>% flag_transient()
View(test)
flag_background <- function(data, min_val = 0.5,
blank_columns = match(
names(
select(data,
contains("blank", ignore.case = TRUE))),
names(data)),
sample_columns = match(
names(
select(data,
-contains("blank", ignore.case = TRUE) &
-contains("feature_number"))),
names(data))) {
require("tidyverse")
data$max_blanks <- apply(data[blank_columns], 1, max)
data$mean_samples <- apply(data[sample_columns], 1, mean, na.rm = TRUE)
no_background <- data%>%
mutate(background_features = case_when(mean_samples*min_val > max_blanks ~ "real",
TRUE ~ "background"))%>%
dplyr::select(-c(max_blanks, mean_samples))
}
test <- feature_table_dirty%>% flag_background()%>% flag_transient()
flag_background <- function(data, min_val = 0.5,
blank_columns = match(
names(
select(data,
contains("blank", ignore.case = TRUE))),
names(data)),
sample_columns = match(
names(
select(data,
-c(contains("blank", ignore.case = TRUE),"feature_number"))),
names(data))) {
require("tidyverse")
data$max_blanks <- apply(data[blank_columns], 1, max)
data$mean_samples <- apply(data[sample_columns], 1, mean, na.rm = TRUE)
no_background <- data%>%
mutate(background_features = case_when(mean_samples*min_val > max_blanks ~ "real",
TRUE ~ "background"))%>%
dplyr::select(-c(max_blanks, mean_samples))
}
test <- feature_table_dirty%>% flag_background()%>% flag_transient()
View(test)
View(test%>% filter(background_features == "real"))
View(feature_table_dirty)
test <- feature_table_dirty%>% flag_background(blank_columns = c(2:9, 260))
View(test)
View(feature_table_dirty)
